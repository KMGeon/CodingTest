# 숨바꼭질 시리즈 BFS 패턴 정리

## 문제 유형별 정리

### 1. 기본 숨바꼭질 (최단 거리만 구하기)
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX = 100000;
int n, k;
int visited[MAX + 4];

int main() {
    cin >> n >> k;
    
    queue<int> q;
    q.push(n);
    visited[n] = 1;  // 시작점을 1로 설정 (0과 구분하기 위해)
    
    while (q.size()) {
        int now = q.front();
        q.pop();
        
        // 3가지 이동 방법
        for (int next : {now - 1, now + 1, now * 2}) {
            if (next >= 0 && next <= MAX && !visited[next]) {
                q.push(next);
                visited[next] = visited[now] + 1;
            }
        }
    }
    
    cout << visited[k] - 1 << '\n';  // 1을 빼서 실제 거리 출력
}
```

### 2. 숨바꼭질 2 (최단 거리 + 경로 개수)
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX = 200000;
int n, k;
int visited[MAX + 4];
long long cnt[MAX + 4];  // 경로 개수를 저장

int main() {
    cin >> n >> k;
    
    // 시작점과 도착점이 같은 경우
    if (n == k) {
        cout << 0 << endl;
        cout << 1 << endl;
        return 0;
    }
    
    queue<int> q;
    visited[n] = 1;
    cnt[n] = 1;  // 시작점까지의 경로는 1개
    q.push(n);
    
    while (q.size()) {
        int now = q.front();
        q.pop();
        
        for (int next : {now - 1, now + 1, now * 2}) {
            if (next >= 0 && next <= MAX) {
                // 첫 방문
                if (!visited[next]) {
                    q.push(next);
                    visited[next] = visited[now] + 1;
                    cnt[next] += cnt[now];
                }
                // 같은 거리로 재방문 (다른 경로)
                else if (visited[next] == visited[now] + 1) {
                    cnt[next] += cnt[now];  // 경로 개수 누적
                }
            }
        }
    }
    
    cout << visited[k] - 1 << '\n';
    cout << cnt[k] << '\n';
}
```

### 3. 숨바꼭질 4 (최단 거리 + 경로 추적)
```cpp
#include <bits/stdc++.h>
using namespace std;

#define prev aaa  // prev는 이미 정의된 함수이므로 재정의

const int MAX = 100000;
int n, k;
int visited[MAX + 4];
int prev[MAX + 4];  // 이전 위치를 저장
vector<int> path;

int main() {
    cin >> n >> k;
    
    queue<int> q;
    q.push(n);
    visited[n] = 1;
    
    while (q.size()) {
        int here = q.front();
        q.pop();
        
        for (int next : {here + 1, here - 1, here * 2}) {
            if (next >= 0 && next <= MAX && !visited[next]) {
                q.push(next);
                visited[next] = visited[here] + 1;
                prev[next] = here;  // 이전 위치 저장
            }
        }
    }
    
    // 경로 역추적
    for (int i = k; i != n; i = prev[i]) {
        path.push_back(i);
    }
    path.push_back(n);
    reverse(path.begin(), path.end());
    
    cout << visited[k] - 1 << endl;
    for (int i : path) cout << i << ' ';
}
```

## 핵심 패턴 정리

### 1. visited 배열 사용법
- visited[n] = 1로 시작 (0과 미방문 구분)
- 실제 거리는 visited[k] - 1로 출력
- BFS 특성상 처음 도달한 것이 최단 거리

### 2. for문 이동 패턴
```cpp
// 숨바꼭질 기본 이동 3가지
for (int next : {now - 1, now + 1, now * 2}) {
    // 범위 체크와 방문 체크
    if (next >= 0 && next <= MAX && !visited[next]) {
        // 처리
    }
}
```
- 순서 주의: 연산 순서에 따라 결과가 달라질 수 있음
- 범위 체크: 0 <= next <= MAX 필수

### 3. prev 배열로 경로 추적
```cpp
// 1. BFS 진행하면서 이전 위치 저장
prev[next] = here;

// 2. 목적지부터 시작점까지 역추적
for (int i = k; i != n; i = prev[i]) {
    path.push_back(i);
}
path.push_back(n);

// 3. 순서 뒤집기 (시작->목적지)
reverse(path.begin(), path.end());
```

### 4. 경로 개수 세기 (cnt 배열)
```cpp
// 첫 방문
if (!visited[next]) {
    visited[next] = visited[now] + 1;
    cnt[next] += cnt[now];
}
// 같은 거리로 재방문
else if (visited[next] == visited[now] + 1) {
    cnt[next] += cnt[now];  // 경로 개수 누적
}
```
- 같은 레벨에 여러 경로로 도달 가능
- 이미 방문했어도 같은 거리면 경로 수 누적

## 주의사항

### 1. 큐에 시작점 넣기 잊지 말 것
```cpp
q.push(n);  // 이거 빼먹으면 -1 출력됨
```

### 2. MAX 값 설정
- 기본 숨바꼭질: 100,000
- 경로 개수 문제: 200,000 (2배 필요할 수 있음)

### 3. prev 키워드 충돌
```cpp
#define prev aaa  // C++ 표준 함수와 충돌 방지
```

### 4. 시작점 = 도착점 예외 처리
```cpp
if (n == k) {
    cout << 0 << '\n';  // 거리
    cout << 1 << '\n';  // 경로 개수
    return 0;
}
```

## 문제별 필요 배열

| 문제 유형 | visited | cnt | prev/parent |
|---------|---------|-----|------------|
| 최단 거리만 | O | X | X |
| + 경로 개수 | O | O | X |
| + 경로 추적 | O | X | O |

## 디버깅 팁

1. -1 출력: 큐에 시작점을 넣지 않았을 가능성
2. 메모리 초과: MAX 값이 너무 크거나 배열 크기 확인
3. 틀렸습니다: 
   - 범위 체크 (0 <= next <= MAX)
   - n == k 예외 처리
   - visited 초기값 설정 (1로 시작)

## 백준 문제 번호
- 1697번: 숨바꼭질 (기본)
- 12851번: 숨바꼭질 2 (경로 개수)
- 13913번: 숨바꼭질 4 (경로 추적)
- 13549번: 숨바꼭질 3 (가중치 다른 경우)