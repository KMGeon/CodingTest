# 🧪 연구소 문제 (백준 14502)

**핵심 패턴**: 완전탐색 + DFS 시뮬레이션

## 🎯 문제 이해

- **목표**: 벽 3개를 추가로 세워서 바이러스 확산 후 안전한 영역을 최대화
- **제약**: 8×8 격자, 빈칸 중 3곳에만 벽 설치 가능
- **바이러스**: 상하좌우로 연결된 빈칸으로 확산

## 🧠 암기용 3단계

### 1. 데이터 수집 📋

- **바이러스 위치들** 따로 모아두기 (virusList)
- **빈 칸 위치들** 따로 모아두기 (wallList)
- 최댓값 변수 준비

### 2. 모든 벽 조합 시도 🔄

- **3중 반복문**으로 빈칸 중 3곳 선택
- 벽 설치 → 바이러스 확산 시뮬레이션 → 벽 복원
- 매번 안전영역 개수 계산해서 최댓값 갱신

### 3. 바이러스 확산 시뮬레이션 🦠

- 모든 바이러스 위치에서 **DFS 시작**
- 상하좌우로 퍼뜨리면서 visited 체크
- 빈칸이면서 방문 안 한 곳 = 안전영역

---

## 📋 수도코드

```
ALGORITHM 연구소_안전영역_최댓값
INPUT: n×m 연구소 지도 (0:빈칸, 1:벽, 2:바이러스)

1. 초기화
   - virusList ← 바이러스 위치들 저장
   - wallList ← 빈 칸 위치들 저장
   - maxSafeArea ← 0

2. 3중 반복문으로 벽 3개 조합 생성
   FOR i = 0 to wallList.size()-1
     FOR j = 0 to i-1  
       FOR k = 0 to j-1
         // 벽 3개 설치
         a[wallList[i]] = 1
         a[wallList[j]] = 1  
         a[wallList[k]] = 1
         
         // 바이러스 확산 시뮬레이션
         safeArea ← SIMULATE_VIRUS_SPREAD()
         maxSafeArea ← max(maxSafeArea, safeArea)
         
         // 벽 복원
         a[wallList[i]] = 0
         a[wallList[j]] = 0
         a[wallList[k]] = 0

3. OUTPUT maxSafeArea

FUNCTION SIMULATE_VIRUS_SPREAD()
   visited 배열 초기화
   
   FOR each virus in virusList
     visited[virus] = true
     DFS(virus.y, virus.x)
   
   safeCount ← 0
   FOR i = 0 to n-1
     FOR j = 0 to m-1
       IF a[i][j] == 0 AND visited[i][j] == false
         safeCount++
   
   RETURN safeCount

FUNCTION DFS(y, x)
   FOR each direction in {상,우,하,좌}
     ny ← y + dy[direction]
     nx ← x + dx[direction]
     
     IF 경계체크 AND visited[ny][nx] == false AND a[ny][nx] != 1
       visited[ny][nx] = true
       DFS(ny, nx)
```

---

## 💡 핵심 포인트

**🧠 암기 키워드:**

1. **"데이터 분류"** - 바이러스/빈칸 위치 저장
2. **"3개 조합 + 시뮬레이션"** - 모든 벽 조합 시도
3. **"DFS 확산 + 안전 카운트"** - 바이러스 퍼뜨리고 남은 곳 세기

**⚡ 주의사항:**

- visited 배열 매번 초기화 필수
- 조합 생성: i > j > k 순서로 중복 방지
- DFS 종료 조건: 경계 + 벽 아님 + 미방문
- 시간복잡도: O(64C3 × 64) ≈ 250만 연산 (충분)

**🔗 비슷한 문제들:**

- 테트로미노 (완전탐색 + 시뮬레이션)
- 치킨 배달 (조합 + 거리계산)
- 연구소 2, 3 (변형 문제들)