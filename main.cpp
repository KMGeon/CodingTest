#include<bits/stdc++.h>
using namespace std;

// y1이 system header에서 정의되어 충돌을 피하기 위한 매크로
#define y1 aaaa

// 전역 변수들
int a[104][104];        // 2D 격자 배열 (1: 직사각형 영역, 0: 빈 공간)
int m, n, k;            // m: 세로 크기, n: 가로 크기, k: 직사각형 개수
int x1, x2, y1, y2;     // 직사각형의 좌하단(x1,y1)과 우상단(x2,y2) 좌표
int visited[104][104];  // 방문 체크 배열
const int dy[4] = {-1, 0, 1, 0};  // 상하좌우 이동을 위한 y 방향 배열
const int dx[4] = {0, 1, 0, -1};  // 상하좌우 이동을 위한 x 방향 배열
vector<int> ret;        // 각 영역의 크기를 저장할 벡터

// DFS를 사용해 연결된 빈 공간의 크기를 계산하는 함수
int dfs(int y, int x) {
    visited[y][x] = 1;  // 현재 위치를 방문 처리
    int ret = 1;        // 현재 셀부터 시작하여 크기를 1로 초기화
    
    // 4방향으로 탐색
    for (int i = 0; i < 4; i++) {
        int ny = y + dy[i];  // 새로운 y 좌표
        int nx = x + dx[i];  // 새로운 x 좌표
        
        // 경계 체크 및 이미 방문한 곳인지 체크
        if (ny < 0 || ny >= m || nx < 0 || nx >= n || visited[ny][nx] == 1) continue;
        
        // 직사각형 영역(값이 1)이면 탐색하지 않음
        if (a[ny][nx] == 1) continue;
        
        // 재귀적으로 연결된 영역 탐색하여 크기 누적
        ret += dfs(ny, nx);
    }
    return ret;
}

int main() {
    // 입출력 속도 최적화
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    // 격자 크기와 직사각형 개수 입력
    cin >> m >> n >> k;

    // k개의 직사각형 정보를 입력받아 격자에 표시
    for (int i = 0; i < k; i++) {
        cin >> x1 >> y1 >> x2 >> y2;
        // 직사각형 영역을 1로 표시 (x1,y1)부터 (x2-1,y2-1)까지
        for (int x = x1; x < x2; x++) {
            for (int y = y1; y < y2; y++) {
                a[y][x] = 1;  // 직사각형 영역 표시
            }
        }
    }

    // 전체 격자를 순회하며 빈 공간(연결된 영역) 찾기
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 빈 공간(0)이면서 아직 방문하지 않은 곳에서 DFS 시작
            if (a[i][j] != 1 && visited[i][j] == 0) {
                ret.push_back(dfs(i, j));  // 연결된 영역의 크기를 벡터에 추가
            }
        }
    }

    // 영역 크기들을 오름차순으로 정렬
    sort(ret.begin(), ret.end());

    // 결과 출력: 영역의 개수와 각 영역의 크기
    cout << ret.size() << "\n";
    for (int area : ret) {
        cout << area << " ";
    }

    return 0;
}

/*
===============================================================================
                    백준 2583번 "영역 구하기" 문제 해결 과정
===============================================================================

📋 문제 요약:
- M×N 격자에 k개의 직사각형을 그린다
- 직사각형으로 막히지 않은 빈 공간들의 각 영역 크기를 구한다
- 영역 개수와 각 영역의 크기를 오름차순으로 출력한다

🎯 핵심 아이디어: 
그래프의 "연결 성분(Connected Component)" 찾기 문제로 변환!

===============================================================================
                              📊 예시로 이해하기
===============================================================================

입력: M=5, N=7, K=3
직사각형 좌표: (0,2,4,4), (1,1,2,5), (4,0,6,2)

1️⃣ 초기 상태 (5×7 격자)
   0 1 2 3 4 5 6 (x축)
0  . . . . . . .
1  . . . . . . .  
2  . . . . . . .
3  . . . . . . .
4  . . . . . . .
(y축)

2️⃣ 직사각형 (0,2,4,4) 표시 → X로 마킹
   0 1 2 3 4 5 6
0  . . . . . . .
1  . . . . . . .  
2  X X X X . . .  ← y=2부터
3  X X X X . . .  ← y=3까지
4  . . . . . . .
   ↑       ↑
   x=0    x=3까지

3️⃣ 직사각형 (1,1,2,5) 추가 표시
   0 1 2 3 4 5 6
0  . . . . . . .
1  . X . . . . .  ← y=1부터
2  X X X X . . .  ← y=2
3  X X X X . . .  ← y=3
4  . X . . . . .  ← y=4까지
   ↑ ↑
   x=1까지만

4️⃣ 직사각형 (4,0,6,2) 추가 표시
   0 1 2 3 4 5 6
0  . . . . X X .  ← y=0부터
1  . X . . X X .  ← y=1까지
2  X X X X . . .  
3  X X X X . . .  
4  . X . . . . .
       ↑     ↑
       x=4  x=5까지

5️⃣ 최종 격자 상태 및 DFS 탐색 순서
   0 1 2 3 4 5 6
0  A A A A X X B  ← 영역 A와 B 발견!
1  A X A A X X B  
2  X X X X C C C  ← 영역 C 발견!
3  X X X X C C C  
4  D X E E E E E  ← 영역 D와 E 발견!

===============================================================================
                          🔍 DFS 동작 과정 상세 분석
===============================================================================

🔄 DFS 탐색 과정:

영역 A 탐색 (시작점: (0,0)):
(0,0) → (0,1) → (0,2) → (0,3)
  ↓       ↓       ↓       ↓
(1,0)   (1,2) → (1,3)    X
  
총 7개 셀 연결됨 → 크기 7

영역 B 탐색 (시작점: (0,6)):
(0,6) → (1,6)
총 2개 셀 연결됨 → 크기 2

영역 C 탐색 (시작점: (2,4)):
(2,4) → (2,5) → (2,6)
  ↓       ↓       ↓
(3,4) → (3,5) → (3,6)
총 6개 셀 연결됨 → 크기 6

영역 D 탐색 (시작점: (4,0)):
(4,0) - 단독
총 1개 셀 → 크기 1

영역 E 탐색 (시작점: (4,2)):
(4,2) → (4,3) → (4,4) → (4,5) → (4,6)
총 5개 셀 연결됨 → 크기 5

===============================================================================
                            🧮 알고리즘 핵심 로직
===============================================================================

핵심 1: 좌표 변환 주의!
입력: (x1, y1, x2, y2) - x가 먼저
배열: a[y][x] - y가 먼저 (행렬 형태)

핵심 2: DFS의 크기 계산
dfs(y, x) {
    visited[y][x] = 1;      // 방문 표시
    int size = 1;           // 현재 셀 크기
    
    상하좌우 4방향 탐색 {
        if (유효한 셀 && 미방문 && 빈공간)
            size += dfs(ny, nx);  // 재귀적으로 크기 누적
    }
    return size;
}

핵심 3: 전체 탐색 패턴
for (모든 셀) {
    if (빈공간 && 미방문) {
        새로운 영역 발견!
        영역크기 = dfs(현재위치);
        결과에 저장;
    }
}

===============================================================================
                              🎯 최종 결과
===============================================================================

발견된 영역들: [7, 2, 6, 1, 5]
정렬 후: [1, 2, 5, 6, 7]

출력:
5        ← 영역 개수
1 2 5 6 7 ← 각 영역 크기 (오름차순)

===============================================================================
                          💡 이 문제에서 배울 수 있는 것들
===============================================================================

✅ 그래프 이론: 연결 성분 찾기의 실제 적용
✅ DFS 활용: 재귀적 크기 계산 패턴
✅ 2D 배열: 좌표계 변환과 경계 처리
✅ 시뮬레이션: 단계별 상태 변화 추적
✅ 정렬: 결과 정리 및 출력 형식

이런 유형의 문제들:
- 섬의 개수 구하기
- 바이러스 전파 시뮬레이션  
- 미로 탐색
- 영역 분할 문제

===============================================================================
*/
