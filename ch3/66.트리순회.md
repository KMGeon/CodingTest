# 트리 순회 (Tree Traversal)

## 정의

**트리 순회**는 트리의 모든 노드를 체계적으로 방문하는 과정입니다. DFS(깊이 우선 탐색)를 기반으로 하며, 노드를 방문하는 순서에 따라 구분됩니다.

### 1. 전위 순회 (Preorder Traversal)
- **순서**: 현재 노드 → 왼쪽 자식 → 오른쪽 자식
- **특징**: 루트부터 처리, 부모 노드를 먼저 방문

### 2. 후위 순회 (Postorder Traversal)  
- **순서**: 왼쪽 자식 → 오른쪽 자식 → 현재 노드
- **특징**: 리프부터 처리, 자식들을 먼저 방문한 후 부모 방문

## 핵심 포인트

- **공통점**: visited 체크와 재귀 구조는 동일
- **차이점**: 출력(처리) 시점만 다름
- **후위순회 활용**: 메모리 해제, 디렉토리 삭제, 수식 계산 등 자식 처리 후 부모 처리가 필요한 경우

## 구현 코드

```cpp
#include <iostream>
#include <vector>
using namespace std;

class DFSTraversal {
private:
    int vertices;
    vector<vector<int>> adj;
    vector<bool> visited;

public:
    DFSTraversal(int v) : vertices(v) {
        adj.resize(v);
        visited.resize(v, false);
    }

    void addEdge(int from, int to) {
        adj[from].push_back(to);
    }

    // 전위순회 (현재 노드 먼저 처리)
    void preOrder(int here) {
        if (visited[here] == false) {
            visited[here] = true;
            cout << here << " ";  // 현재 노드 먼저 처리

            if (adj[here].size() == 1) preOrder(adj[here][0]);
            if (adj[here].size() == 2) {
                preOrder(adj[here][0]);
                preOrder(adj[here][1]);
            }
        }
    }

    // 후위순회 (자식들 먼저 방문)
    void postOrder(int here) {
        if (visited[here] == false) {
            // 자식들 먼저 방문
            if (adj[here].size() == 1) postOrder(adj[here][0]);
            if (adj[here].size() == 2) {
                postOrder(adj[here][0]);
                postOrder(adj[here][1]);
            }

            visited[here] = true;
            cout << here << " ";  // 후위 순서로 출력
        }
    }

    // 전위순회 실행
    void runPreOrder(int start = 0) {
        fill(visited.begin(), visited.end(), false);
        cout << "전위순회: ";
        preOrder(start);
        cout << endl;
    }

    // 후위순회 실행
    void runPostOrder(int start = 0) {
        fill(visited.begin(), visited.end(), false);
        cout << "후위순회: ";
        postOrder(start);
        cout << endl;
    }
};

int main() {
    DFSTraversal graph(6);

    // 트리 구성:     0
    //             /   \
    //            1     2
    //           / \     \
    //          3   4     5
    graph.addEdge(0, 1);
    graph.addEdge(0, 2);
    graph.addEdge(1, 3);
    graph.addEdge(1, 4);
    graph.addEdge(2, 5);

    graph.runPreOrder();   // 출력: 0 1 3 4 2 5
    graph.runPostOrder();  // 출력: 3 4 1 5 2 0

    return 0;
}
```