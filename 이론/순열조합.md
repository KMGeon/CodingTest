# 순열 & 조합 완벽 정리

## 🎯 핵심 개념

### 순열 vs 조합 구분법

```
{1,2,3}에서 2개 뽑기

🔄 순열 (Permutation) - 순서 O
{1,2}, {2,1}, {1,3}, {3,1}, {2,3}, {3,2} → 6가지

🎯 조합 (Combination) - 순서 X
{1,2}, {1,3}, {2,3} → 3가지

```

**문제에서 이런 키워드가 나오면 순열:**

- "순서를 재배치하여"
- "~한 순서의 경우"
- "배열하는 방법의 수"

---

## 📋 순열 (Permutation)

### 수학 공식

- **nPr = n! / (n-r)!**
    - eg : 3개의 카드 중에서 2개를 뽑는다. 3P2
- n: 전체 개수, r: 뽑는 개수

### ⚡ 방법 1: next_permutation (추천)

**언제 사용:** 간단하고 빠르게 모든 순열이 필요할 때

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v{2, 1, 3, 100, 200};

    // 🚨 반드시 오름차순 정렬!
    sort(v.begin(), v.end());

    do {
        // r개만 출력하고 싶다면 (여기서는 2개)
        for(int i = 0; i < 2; i++) {
            cout << v[i] << " ";
        }
        cout << '\n';

        // 전체 순열을 보고 싶다면
        // for(int x : v) cout << x << " ";

    } while(next_permutation(v.begin(), v.end()));

    return 0;
}

```

**⚠️ 주의사항:**

1. **반드시 오름차순으로 정렬** 후 사용
2. 중복 원소는 자동으로 중복 제거됨
3. 배열 사용시 마지막에 -1 하면 안됨

### ⚡ 방법 2: 재귀 함수

**언제 사용:** 조건이 복잡하거나 과정에서 추가 로직이 필요할 때

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> v{1, 2, 3};
bool visited[10]; // 사용 여부 체크

// n: 전체 개수, r: 뽑을 개수, depth: 현재 깊이
void makePermutation(int n, int r, int depth) {
    // 종료 조건: r개 다 뽑았으면
    if(depth == r) {
        for(int i = 0; i < r; i++) {
            cout << v[i] << " ";
        }
        cout << '\n';
        return;
    }

    // depth번째 자리에 올 수 있는 모든 원소 시도
    for(int i = depth; i < n; i++) {
        swap(v[i], v[depth]);        // 선택
        makePermutation(n, r, depth + 1);  // 재귀
        swap(v[i], v[depth]);        // 복구 (백트래킹)
    }
}

int main() {
    makePermutation(3, 3, 0);  // 3개 중 3개 뽑는 순열
    return 0;
}

```

---

## 🎯 조합 (Combination)-  순서와 관계가 없다.

### 수학 공식

- **nCr = n! / (r! × (n-r)!)**

<aside>
💡

nCr = nCn-r (조합의 특징)

</aside>

### ⚡ 방법 1: 재귀 함수 (r ≥ 4일 때 추천)

```

```cpp
#include <bits/stdc++.h>
using namespace std;

int n = 5, k = 3;
int a[5] = {1, 2, 3, 4, 5};

void print(vector<int>& b) {
    for(int x : b) cout << x << " ";
    cout << '\n';
}

// start: 시작 인덱스, b: 현재까지 선택한 원소들
void combi(int start, vector<int>& b) {
    // 종료 조건: k개 다 선택했으면
    if(b.size() == k) {
        print(b);
        return;
    }

    // start+1부터 n-1까지 시도
    for(int i = start + 1; i < n; i++) {
        b.push_back(a[i]);     // 선택
        combi(i, b);           // 재귀 (i 이후부터 선택)
        b.pop_back();          // 복구
    }
}

int main() {
    vector<int> b;
    combi(-1, b);  // -1부터 시작 (첫 번째 호출에서 0부터 시작하도록)
    return 0;
}

조합 생성 과정 (n=5, k=3 예시)

                    combi(0, [])
                         |
            ┌────────────┼────────────┐
         선택1        선택2        선택3...
        a[0]=1       a[1]=2       a[2]=3
            |            |            |
    combi(1,[1])   combi(2,[2])   combi(3,[3])
         |              |              |
    ┌────┼────┐    ┌────┼────┐    ┌────┼────┐
   a[1] a[2] a[3]  a[2] a[3] a[4]  a[3] a[4] ...
    |    |    |     |    |    |     |    |
   [1,2][1,3][1,4] [2,3][2,4][2,5] [3,4][3,5]
    |    |    |     |    |    |     |    |
  최종조합 생성 과정 (k=3일 때 한 단계 더 진행)

출력 결과:
1 2 3
1 2 4  
1 2 5
1 3 4
1 3 5
1 4 5
2 3 4
2 3 5
2 4 5
3 4 5

백트래킹 과정:
선택 → 재귀 → 선택취소(pop_back) → 다음원소 시도
```

### ⚡ 방법 2: 중첩 for문 (r ≤ 3일 때 추천)

```cpp
// 5개 중 3개 조합 (nC3)
for(int i = 0; i < n; i++) {
    for(int j = i + 1; j < n; j++) {
        for(int k = j + 1; k < n; k++) {
            cout << a[i] << " " << a[j] << " " << a[k] << '\n';
        }
    }
}

```

---

## 🚀 실전 활용 가이드

### 언제 뭘 쓸까?

| 상황 | 방법 | 이유 |
| --- | --- | --- |
| 간단한 순열 | `next_permutation` | 코드가 짧고 직관적 |
| 조건부 순열 | 재귀 | 중간에 가지치기 가능 |
| r ≤ 3 조합 | 중첩 for문 | 가장 빠름 |
| r ≥ 4 조합 | 재귀 | for문 중첩이 너무 깊어짐 |

### 시간복잡도 체크

- **순열**: O(n!) → n ≤ 8~9 정도가 안전
- **조합**: O(nCr) → n ≤ 20 정도가 안전

### ⚠️ 자주 하는 실수들

1. `next_permutation` 사용 전 정렬 안함
2. 재귀에서 백트래킹(복구) 안함
3. 전역 변수와 지역 변수 범위 헷갈림
4. 인덱스 범위 실수 (0 base vs 1 base)

---

## 💡 문제별 접근 전략

### 순열 문제 유형

- **전체 순열**: `next_permutation` 사용
- **부분 순열**: 재귀로 r개만 선택
- **조건부 순열**: 재귀 + 가지치기

### 조합 문제 유형

- **전체 조합**: 재귀 함수
- **고정 r값**: 중첩 for문 (r이 작을 때)
- **부분합 문제**: 조합 + 합계 계산

### 🔥 팁: 문제 해결 순서

1. **순열 vs 조합 구분**
2. **전체 개수 n, 선택 개수 r 파악**
3. **시간복잡도 계산** (시간제한 확인)
4. **적절한 구현 방법 선택**
5. **예시로 검증** 후 제출